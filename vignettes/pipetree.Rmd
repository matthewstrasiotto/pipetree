---
title: "Getting Started"
author: "Matthew Mark Strasiotto"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include= FALSE}
#library(pipetree)
```

# Intoduction to Pipetree

## Context / Assumptions

- You are a programmer, or analyst, who needs access to a project's dataset.
- This project utilizes a `drake` workflow, and the data directory of the
  project is structured to contain a subdirectory containing raw input data,
  and all output data is stored in a [drake::drake_cache()] within the data
  directory.
- there may be more than one dataset of interest, to which the same workflow is applied
    - If there are multiple datasets of interest, these datasets are stored in completely
      separate directories, with an identical structure to one another.
- This data directory may reside in a remote filesystem / volume
    - If the data directory is stored remotely, this remote volume must be able to be mounted
      on the local filesystem
    - For information on mounting filesystems powered by `sshfs`, (Such as USYD's RCOS, or USYD's
      HPC filesystem), see [this document](https://ctdshub.atlassian.net/wiki/spaces/HEAL/pages/840204341/Mount+RCOS+hpc+project+STEMI).
    - Examples of remote volumes in which data could be stored include:
        - USYD's High Performance Computing Cluster's network filesystem, and
        - USYD's RCOS data share.
- It is assumed that you have some knowledge of basic usage of `drake` functions, or at least 
  [functions for drake cache usage](https://docs.ropensci.org/drake/reference/index.html#section-cache-usage)


## Overview

The goal of pipetree is to make navigating the project structure of the 
speed-extract project as simple as possible, and to automate the most commonly
used tasks in accessing and exploring the dataset.

The most important functionalities provided are as follows:

1. Consistent access of a given dataset's root directory accross remote
   volumes, whose mount points may change ( [portrpaths::PortrPath]. )
1. Consistent Access to the filetree structure, that is used by the any 
   SPEED-EXTRACT pipeline workflow/dataset.
1. Straightforward access to the [drake::drake_cache()] for a particular 
   dataset. 
   IE- Immediate access to the results, outputs, and targets generated by the
   data pipeline, as soon as these results are available.
1. __PLANNED__ access to structured metadata for a given dataset, so:
   * users have useful information about the distinguishing characteristics      of that dataset, and 
   * projects have useful aliases for structured and versioned logging of 
     target statistics.  
     - Use cases for this include:
        1. Allowing versioned tracking of multiple datasets'  
           [drake::drake_cache_log], within a versioned project/repo within
           separate subdirectories of the project that builds 
           these targets.
        1. Allowing more in-depth data versioning, such as versioned `yaml`
           files describing high level aggregates of a given 
           dataframe across the workflow, eg
           ```yaml
           n_journeys: 100
           n_journeys_stemi: 5
           ```
         
# Portable Access to Datasets

Portable access to datasets is driven by the [portrpaths::PortrPath] class, 
using the [get_portrpaths()] function.

This expects a local `yaml` config file at a location specified by the user.
This may be specified in one of a few ways:

## Using the pipetree.config option

By setting the global option `pipetree.config = /path/to/your/config.yaml`,
possibly in your user level *.Rprofile* (*~/.Rprofile*), or your project-level
*Rprofile* (`here::here()` */.Rprofile* ), a consistent location for this 
configuration file may be specified. 
This option may be useful for interactive users, but it is not recommended
that package developers include this in any of their code, though it may
be appropiate for a project level *.Rprofile*.
```{r, include = FALSE}
temp_root <- tempdir()
option_config <- file.path(temp_root, "option_config.yaml")
default_config <- pipetree::default_config_path()

file.copy("./option_config.yaml", option_config)
file.copy("./default_config.yaml", default_config)
```

### Examining the config

Lets examine the file we're going to tell our options to use

The path:
```{r}
cat(option_config, sep = "\n")
```

The contents:
```{r}
for (ln in readLines(option_config)) cat(ln, sep = "\n")
```

### Setting the option
```{r}
options(pipetree.config = option_config)
```

Now let's load this configuration:
```{r}
portrpath <- pipetree::get_portrpath()
portrpath
```

## Using an envrionment variable

The path may also be set using a system env variable:

`r pipetree:::pipetree_config_env_var()`.

Set this in your `~/.bashrc`, `.Renviron`, or wherever suits you.

## Allowing the default path to be used

The default path for the configuration is relative to the active 
Rproject, and given by pipetree::default_config_path().

```{r}
default_config <- pipetree::default_config_path()
cat(default_config, sep = "\n")
```

Examining its contents:
```{r}
for (ln in readLines(default_config)) cat(ln, sep = "\n")
```

Calling get_portrpath() with `pipetree.config` unset will behave differently:
```{r}
options(pipetree.config = NULL)
portrpath <- pipetree::get_portrpath()
portrpath
```

## Setting the path explicitly

The path may be set explicitly using the `config_path` argument.
```{r}
portrpath <- pipetree::get_portrpath(config_path = option_config)
portrpath
```

Let's return to the convenience of using the `options(pipetree.config)`,
for now.
```{r}
options(pipetree.config = option_config)
portrpath <- pipetree::get_portrpath()
```

## Using the config

For demonstration purposes, let's set our project directory to
a temporary directory.
```{r}
portrpath$add_profile("temp", temp_root)
portrpath$profile <- "temp"
portrpath
```

# Access to the filetree

To access the filetree, we use get_paths(), similarly to how we loaded our 
config.
```{r}
paths <- pipetree::get_paths()
paths
```

# Accessing the cache

For this demonstration, there is no real cache in place, but we can pretend.

```{r}
cache <- pipetree::get_cache()
```

To use this cache to extract a target, for example, we have a target
in our drake::drake_plan() called `mtcars`, we do the following:
```{r, eval=FALSE}
mtc <- drake::readd(mtcars, cache = cache)
```

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache_access.R
\name{load_merged_partitions}
\alias{load_merged_partitions}
\title{Load and merge all partitions that match a prefix}
\usage{
load_merged_partitions(..., cache = NULL)
}
\arguments{
\item{...}{names of the target collections, as names (symbols) or chracter
strings, specifying the prefix of each parition set, that directly
precedes a given subpartition's index.
For example, to load and combine \code{journey_analysis_base_1},
\code{journey_analysis_base_2}, ..., \code{journey_analysis_base_50}, supply
\code{journey_analysis_base} as an argument.}

\item{cache}{the \link[drake:drake_cache]{drake::drake_cache} object from which the values will be
retrieved}
}
\value{
a named list of dataframes retrieved from the cache and combined.
Each dataframe is named according the the input prefix.
}
\description{
Often, for performance and scalability reasons, dataframes across the
pipeline are "partitioned" into chunks, and these chunks are processed in
parallel.

For example, a dataframe, such as \code{note_data_prepr} might be split into 50
partitions.

Each partition is named like so: \verb{note_data_prepr_\{partition_index\}}, eg,
\code{note_data_prepr_1}, \code{note_data_prepr_2}, ...  \code{note_data_prepr_50}.

This is useful for the HPC, but acessing the full dataset is a pain for users.
This function allows a user to specify the table name they want to extract, eg
\code{note_data_prepr}, and each partition \verb{note_data_prepr_``1},\code{2},\code{3} etc will be
loaded and row binded.
}
\concept{cache_access}
